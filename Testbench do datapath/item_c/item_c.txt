-- c) Copie 3 valores da memória para 3 registradores diferentes


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity tb_datapath is
end tb_datapath;

architecture Behavioral of tb_datapath is

    constant CLK_PERIOD : time := 10 ns;
    constant N : integer := 16;

    signal s_clk        : std_logic := '0';
    signal s_reset      : std_logic := '1';

    signal s_rn_sel     : std_logic_vector(2 downto 0);
    signal s_rm_sel     : std_logic_vector(2 downto 0);
    signal s_rd_sel     : std_logic_vector(2 downto 0);
    signal s_rd_wr      : std_logic;
    signal s_op_ula     : std_logic_vector(3 downto 0);
    signal s_rd_ram     : std_logic_vector(N-1 downto 0);
    signal s_rd_immd    : std_logic_vector(N-1 downto 0);
    signal s_sel_rd_mux : std_logic_vector(1 downto 0);
    signal s_mux_ram    : std_logic;
    signal s_we         : std_logic_vector(0 downto 0); -- RAM write enable

begin

    -- Instancia o CPU_WRAPPER com datapath, mux e RAM
    DUT: entity work.cpu_wrapper
        port map (
            clk           => s_clk,
            rst           => s_reset,
            op_ula_0      => s_op_ula,
            Rn_sel_0      => s_rn_sel,
            Rd_sel_0      => s_rd_sel,
            Rm_sel_0      => s_rm_sel,
            Rd_wr_0       => s_rd_wr,
            Rd_immd_0     => s_rd_immd,
            sel_Rd_mux_0  => s_sel_rd_mux,
            sel_0         => s_mux_ram,
            wea_0         => s_we
        );

    -- Clock
    s_clk <= not s_clk after CLK_PERIOD / 2;

    -- Processo principal de estímulos
    stim_proc: process
    begin
        -- Reset inicial
        s_reset      <= '1';
        s_rd_wr      <= '0';
        s_we         <= "0";
        s_sel_rd_mux <= "00";
        s_op_ula     <= "0000";
        wait for 2*CLK_PERIOD;
        s_reset <= '0';
        wait for CLK_PERIOD;

        -----------------------------------------------
        -- ETAPA 1: Escreve valores na RAM nos endereços 0, 1 e 2
        -- (para simular a inicialização da RAM)
        -----------------------------------------------
        s_mux_ram <= '0'; -- mux: pega dado de Rn
        s_sel_rd_mux <= "10"; -- imediato
        s_rd_wr <= '1';

        -- Carrega Rn com 100 → para escrever na RAM[0]
        s_rd_sel <= "001";          -- R1 = 100
        s_rd_immd <= x"0064";
        wait for CLK_PERIOD;
        s_rd_wr <= '0';

        -- Endereço Rm = 0
        s_rd_sel <= "000";          -- R0 = 0
        s_rd_immd <= x"0000";
        s_rd_wr <= '1';
        wait for CLK_PERIOD;
        s_rd_wr <= '0';

        s_rn_sel <= "001"; -- dado: R1 = 100
        s_rm_sel <= "000"; -- endereço: R0 = 0
        s_we     <= "1";
        wait for CLK_PERIOD;
        s_we     <= "0";

        -- RAM[1] = 200
        s_rd_sel <= "001"; 
        s_rd_immd <= x"00C8"; 
        s_rd_wr <= '1'; 
        
            wait for CLK_PERIOD; s_rd_wr <= '0'; -- R1 = 200
        s_rd_sel <= "000"; 
        s_rd_immd <= x"0001"; 
        s_rd_wr <= '1'; 
        
            wait for CLK_PERIOD; 
        s_rd_wr <= '0'; -- R0 = 1
        s_we <= "1"; 
        
            wait for CLK_PERIOD; 
        s_we <= "0";

        -- RAM[2] = 300
        s_rd_sel <= "001"; 
        s_rd_immd <= x"012C"; 
        s_rd_wr <= '1'; 
            
            wait for CLK_PERIOD; 
        
        s_rd_wr <= '0'; -- R1 = 300
        s_rd_sel <= "000"; 
        s_rd_immd <= x"0002"; 
        s_rd_wr <= '1'; 
            
            wait for CLK_PERIOD; 
        
        s_rd_wr <= '0'; -- R0 = 2
        s_we <= "1"; 
        
            wait for CLK_PERIOD; 
        
        s_we <= "0";

        wait for CLK_PERIOD;

        -----------------------------------------------
        -- ETAPA 2: Lê os valores da RAM para registradores R4, R5, R6
        -----------------------------------------------

        -- RAM[0] -> R4
        s_sel_rd_mux <= "01"; -- selecionar dado vindo da RAM
        s_rm_sel <= "000"; -- R0 = 0 (endereço)
        s_rd_sel <= "100"; -- R4
        s_rd_wr  <= '1';
        
            wait for CLK_PERIOD;
        
        s_rd_wr <= '0';
            
            wait for CLK_PERIOD;

        -- RAM[1] -> R5
        s_rd_sel <= "100"; 
        s_rd_immd <= x"0001"; 
        s_rd_wr <= '1'; 
            
            wait for CLK_PERIOD;
            
        s_rd_wr <= '0'; -- R4 = 1 (endereço)
        s_rm_sel <= "100"; -- R4 = 1
        s_rd_sel <= "101"; -- R5
        s_rd_wr <= '1';
        
            wait for CLK_PERIOD;
        
        s_rd_wr <= '0';
        
            wait for CLK_PERIOD;

        -- RAM[2] -> R6
        s_rd_sel <= "100"; 
        s_rd_immd <= x"0002"; 
        s_rd_wr <= '1'; 
        
            wait for CLK_PERIOD; 
        
        s_rd_wr <= '0'; -- R4 = 2
        s_rm_sel <= "100"; -- R4 = 2
        s_rd_sel <= "110"; -- R6
        s_rd_wr <= '1';
        
            wait for CLK_PERIOD;
        
        s_rd_wr <= '0';

        wait;

    end process;

end Behavioral;

---------------------------------------------------------------------------------------------------------------------------------------------------

CPU_WRAPPER

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity cpu_wrapper is
  port (
    clk           : in  std_logic;
    rst           : in  std_logic;
    
    -- Controle do datapath
    op_ula_0      : in  std_logic_vector(3 downto 0);
    Rn_sel_0      : in  std_logic_vector(2 downto 0);
    Rd_sel_0      : in  std_logic_vector(2 downto 0);
    Rm_sel_0      : in  std_logic_vector(2 downto 0);
    Rd_wr_0       : in  std_logic;
    Rd_immd_0     : in  std_logic_vector(15 downto 0);
    sel_Rd_mux_0  : in  std_logic_vector(1 downto 0);
    
    -- Controle da RAM externa
    sel_0         : in  std_logic;
    wea_0         : in  std_logic_vector(0 downto 0)
  );
end cpu_wrapper;

architecture STRUCTURE of cpu_wrapper is

  signal s_rm        : std_logic_vector(15 downto 0);
  signal s_rn        : std_logic_vector(15 downto 0);
  signal s_dina_mux  : std_logic_vector(15 downto 0);
  signal s_rd_ram    : std_logic_vector(15 downto 0); -- RECEBE da RAM

  component datapath
    generic (N : integer := 16);
    port (
      op_ula      : in  std_logic_vector(3 downto 0);
      rn_sel      : in  std_logic_vector(2 downto 0);
      rd_sel      : in  std_logic_vector(2 downto 0);
      rm_sel      : in  std_logic_vector(2 downto 0);
      rd_wr       : in  std_logic;
      rd_ram      : in  std_logic_vector(15 downto 0);
      rd_immd     : in  std_logic_vector(15 downto 0);
      sel_rd_mux  : in  std_logic_vector(1 downto 0);
      rm          : out std_logic_vector(15 downto 0);
      rn          : out std_logic_vector(15 downto 0);
      clk         : in  std_logic;
      rst         : in  std_logic
    );
  end component;

  component mux2x1_v1_0
    port (
      I0   : in  std_logic_vector(15 downto 0);
      I1   : in  std_logic_vector(15 downto 0);
      sel  : in  std_logic;
      O0   : out std_logic_vector(15 downto 0)
    );
  end component;

  component blk_mem_gen_0
    port (
      addra : in  std_logic_vector(15 downto 0);
      clka  : in  std_logic;
      dina  : in  std_logic_vector(15 downto 0);
      douta : out std_logic_vector(15 downto 0);
      wea   : in  std_logic_vector(0 downto 0)
    );
  end component;

begin

  datapath_inst : datapath
    generic map (N => 16)
    port map (
      op_ula     => op_ula_0,
      rn_sel     => Rn_sel_0,
      rd_sel     => Rd_sel_0,
      rm_sel     => Rm_sel_0,
      rd_wr      => Rd_wr_0,
      rd_ram     => s_rd_ram,
      rd_immd    => Rd_immd_0,
      sel_rd_mux => sel_Rd_mux_0,
      rm         => s_rm,
      rn         => s_rn,
      clk        => clk,
      rst        => rst
    );

  -- Multiplexador para escrita (se necessário em outras tarefas)
  mux_inst : mux2x1_v1_0
    port map (
      I0  => s_rn,
      I1  => s_rm,
      sel => sel_0,
      O0  => s_dina_mux
    );

  -- RAM com escrita e leitura
  ram_inst : blk_mem_gen_0
    port map (
      addra => s_rm,
      clka  => clk,
      dina  => s_dina_mux,
      douta => s_rd_ram,
      wea   => wea_0
    );

end STRUCTURE;
